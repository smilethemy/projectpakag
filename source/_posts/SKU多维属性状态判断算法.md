title: SKU多维属性状态判断算法
date: 2018-01-19
tags: design
categories: java

---
（本文为阅读笔记，具体原文参考[前端如何展示商品属性：SKU多维属性状态判断算法的应用](http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&mid=2247484853&idx=1&sn=bed59c1d83c3aeb4bf7881be8dbdd917&chksm=97236777a054ee61fc3cef07eb4b164fa28e26917ce0a409d876964ad3c2ee3f90a000e29beb#rd)）
<center>问题描述</center>
---

这个问题来源于选择商品属性的场景。比如我们买衣服、鞋子这类物件，一般都需要我们选择合适的颜色、尺码等属性。如下图所示：
![](\img\1.webp)
![](../img/1.webp)
先了解一下**SKU**的学术概念吧：

> 最小库存单元（stock keeping unit，SKU）是一个会计学名词，定义为库存管理中的最小可用单元
> 例如纺织品中的一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。
> 最小库存管理单元可以区分不同商品销售的最小单元
> 是科学管理商品采购、销售、物流和财务管理以及POS和MIS系统的数据统计的需求，通常对应一个管理信息系统的编码

简单的结合上面的实例来说：**SKU**就是你上购物网站买到的最终商品，对应的上图中已选择的属性是：颜色**黑色**-尺码**37**。
我先看看后端数据结构一般是这样的，一个线性数组，每个元素是一个描述当前**SKU**的**map**，比如：
![](\img\2.webp)
![](../img/2.webp)
前端展示的时候显然需要**group**一下，按不同的属性分组，目的就是让用户按属性的维度去选择**group**后的数据大概是这样的：
![](\img\3.webp)
![](../img/3.webp)
对应的在网页上大概是这样的**UI**：
![](\img\4.webp)
![](../img/4.webp)
这个时候，就会有一个问题，这些元子属性能组成的集合（用户的选择路径）**远远大于**真正可以组成的集合，比如上面的属性集合可以组合成一个**笛卡尔积**，即。可以组合成以下序列：
![](\img\5.webp)
![](../img/5.webp)
根据公式可以知道，**一个由3个元素，每个元素是有3个元素的子集构成的集合，能组成的笛卡尔积一共有3的3次幂，也就是27种**，然而源数据只可以形成3种组合。

这种情况下最好能提前判断出来不可选的路径并置灰，告诉用户，否则会造成误解。
<center>确定规则</center>
---

看下图，如果我们定义红色为当前选中的商品的属性，即当前选中商品为**红-大-A**，这个时候如何确认其它非已选属性是否可以组成可选路径？
![](\img\6.webp)
![](../img/6.webp)
**规则是这样的**：假设当前用户想选**白-大-A**，刚好这个选择路径是不存在的，那么我们就把**白**置灰
![](\img\7.webp)
![](../img/7.webp)
以此类推，如果要确认**蓝**属性是否可用，需要查找**蓝-大-A**路径是否存在……
<center>解决方法</center>
---

根据上面的逻辑代码实现思路就有了：


> 遍历所有非已选元素：**"白","蓝","中","小","B","C"**

> 1)取：a)当前元素b)非当前元素所在的其它属性已选元素，形成一个路径
> 2)判断此路径是否存在，如果不存在将当前元素置灰
> 3)遍历所有属性行：**"颜色","尺码","型号"**

看来问题似乎已经解决了，然而，我们忽略了一个非常重要的问题：上例中虽然**白**元素置灰，但是实际上**白**是可以被点击的！因为用户可以选择**白-中-B**路径。

如果用户点击了**白**情况就变得复杂了很多，我们假设用户**只选择了一个**元素**白**，此时如何判断其它未选元素是否可选？
![](\img\8.webp)
![](../img/8.webp)
即：如何确定**"大","中","小","A","B","C"**需要置灰？注意我们并不需要确认**"红"，"蓝"**是否可选，因为属性里面的元素都是**单选**，当前的属性里任何元素都可选的
<center>缩小问题规模</center>
---

我们先**缩小问题范围**：当前情况下（只有一个**白**已选）如何确定尺码**"大"**需要置灰？你可能会想到根据我们之间的逻辑，需要分别查找：

> **白-大-A**

> **白-大-B**

> **白-大-C**

他们都不存在的时候把尺码**大**置灰，问题似乎也可以解决。其实这样是不对的，因为**型号没有被选择过**，所以只需要知道**白-大**是否可选即可

同时还有一个问题，如果已选的个数不确定而且维度可以增加到不确定呢？
![](\img\9.webp)
![](../img/9.webp)
这种情况下如果还按之前的算法，即使实现也非常复杂。这时候就要考虑换一种思维方式。
<center>调整思路</center>
---

之前我们都是反向思考，找出不可选应该置灰的元素。我们现在正向的考虑，如何确定属性是否可选。而且多维的情况下用户可以跳着选。比如：用户选了两个元素**白，B**
![](\img\10.webp)
![](../img/10.webp)
我们再回过头来看下**原始存在的数据：**
![](\img\11.webp)
![](../img/11.webp)
显然：如果第一条数据**"红","大","A"**存在，那么下面这些子组合**肯定都存在：**

> 红

> 大

> A

> 红-大

> 红-A

> 大-A

> 红-大-A

同理：如果第二条数据**"白","中","B"**存在，那么下面这些子组合**肯定都存在：**

> 白

> 中

> B

> 白-中

> 白-B

> 中-B

> 白-中-B

...

我们提前把**所有存在的路径中的子组合**算出来，算法上叫取集合所有子集，数学上叫**幂集**，形成一个所有存在的路径表，算法如下：
![](\img\12.webp)
![](../img/12.webp)
有了这个存在的子集集合，再回头看之前的举例：
![](\img\13.webp)
![](../img/13.webp)

> 如何确定**红**可选？只需要确定**红-B**可选

> 如何确定**中**可选？需要确定**白-中-B**可选

> 如何确定**2G**可选？需要确定**白-B-2G**可选

算法描述如下：

> 遍历所有非已选元素

> 1)取：a)当前元素b)非当前元素所在的其它属性已选元素（**如果当前属性中没已选元素，则跳过**），形成一个路径。

> 2)判断此路径是否存在（**在所有存在的路径表中查询**），如果不存在将当前元素置灰。

> 3)遍历所有属性行。

以最开始的后端数据为例，生成的所有可选路径表如下：注意路径用分割符号「-」分开是为了查找路径时方便，不用遍历。
![](\img\14.webp)
![](../img/14.webp)
为了更清楚的说明这个算法，再上一张图来解释下吧：
![](\img\15.webp)
![](../img/15.webp)
所以根据上面的逻辑得出，计算状态后的界面应该是这样的：
![](\img\16.webp)
![](../img/16.webp)
现在这种情况下如果用户点击尺码**中**应该怎么交互呢？
<center>优化体验</center>
---

因为当前情况下路径**红-中-A**并不存在，如果点击**中**，那么除了尺码**中**之外其它的属性中**至少有一个**属性和**中**的路径搭配是不存在的

交互方面需求是：如果不存在就高亮当前属性行，使用户必须选择到可以和**中**组合存在的属性。而且用户之间选择过的属性要做一次缓存

所以当点击不存在的属性时交互流程是这样的：

无论当前属性存不存在，先高亮（选中）当前属性；

> 清除其它所有已选属性；

> 更新当前状态（只选当前属性）下的其它属性可选状态；

> 遍历非当前属性行的其它属性查找对应的在缓存中的已选属性；

> 如果缓存中对应的属性存在（可选），则默认选中缓存属性并**再次更新**其它可选状态。不存在，则高亮当前属性行（深色背景）。

这个过程的流程图大概是这样的，点进不存在的属性就会进入「单选流程」。
![](\img\17.webp)
![](../img/17.webp)
假设后端数据是这样的：
![](\img\18.webp)
![](../img/18.webp)
![](\img\19.webp)
![](../img/19.webp)
如果用户点击**中**。这个时候**白-中**是存在的，但是**中-A**并不存在，所以保留颜色**白**，高亮型号属性行：
![](\img\20.webp)
![](../img/20.webp)
由此可见和**白-中**能搭配存在型号只有**B**，而缓存的作用就是为了少让用户选一次颜色白

到这里，基本上主要的功能就实现了。比如库存逻辑处理方式也和不存属性一样，就不再赘述。唯一需要注意的地方是求幂集的复杂度问题。
<center>算法复杂度</center>
---

幂集算法的时间复杂度是**O(2^n)**，也就是说每条数据上面的属性（维度）越多，复杂度越高。**SKU**数据的多少并不重要，因为是常数级的线性增长，而维度是指数级的增长。
![](\img\21.webp)
![](../img/21.webp)
![](\img\22.webp)
![](../img/22.webp)
在**Chrome**里面简单跑了几个用例，可见这个算法非常低效，如果要使用这个算法，必须控制维度在合理范围内，而且不仅仅算法时间复杂度很高，生成最后的路径表也会非常大，相应的占用内存也很高。

举个例子：如果有一个10维的SKU，那么最终生成的路径表会有2^10个（1024）key/value。

最终**demo**可以查看这个：[**SKU**多维属性状态判断](http://codepen.io/keelii/pen/RoOzgb)